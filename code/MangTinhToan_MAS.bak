<?xml version="1.0" encoding="UTF-8"?>
<Worksheet><Version major="6" minor="1"/><View-Properties><Zoom percentage="200"/></View-Properties><Styles><Layout alignment="left" firstindent="0.0" leftmargin="0.0" linebreak="space" linespacing="0.0" name="Normal" rightmargin="0.0" spaceabove="0.0" spacebelow="0.0"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="Maple Input"/><Font background="[0,0,0]" family="Times New Roman" name="Page Number" underline="false"/></Styles><Page-Numbers enabled="false" first-number="1" first-numbered-page="1" horizontal-location="right" style="Page Number" vertical-location="bottom"/><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan := table():</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false"> </Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan[ReadObjectw] := proc(filename::string)
local nameobject, F, M, f, i, t, m, s, p, helpob;
  s := readline(filename);
  M := [];
  f := [];
  i := 1;
  F := [];
  helpob := [];
  if s = 0 then
    print("file rong")
  else
    while s = "" do
       s := readline(filename)
    od;
    nameobject := rhs(parse(s));
    helpob := [op(helpob), s];
    s := readline(filename);
    while searchtext("variables",s)=0  do
      s := readline(filename)
    od;
    s := readline(filename);
    while searchtext("endvariables",s) = 0 do
      if s &lt;&gt; "" then
        M := [op(M), lhs(parse(s))];
        helpob := [op(helpob), s]
      fi;
      s := readline(filename)
    od;
    s := readline(filename);
    if M = [] then
      ERROR("variables=[]")
    fi;
    while s &lt;&gt; 0 do
      if s &lt;&gt; "" then
        if i &lt; 7 then
          if i &lt;&gt; 1 then
            if i &lt;&gt; 5 then
              f := [op(f), rhs(parse(s))]
            else
              f := [op(f), {rhs(parse(s))[]}]
            fi
          else
            f := [op(f), s]
          fi;
          i := i+1
        else
          i := 1;
          f := [op(f), rhs(parse(s))];
          F := [op(F),f];
          f := []
        fi
      fi;
      s := readline(filename)
   od
  fi;
  RETURN([nameobject, M, F, helpob]);
end:# ReadObjectw</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan[Baodongw]:=proc(F::set,A::set)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">  # F la tap hop cac quan he
  # A la tap hop cac thuoc tinh hay cac phan tu
 local f,F1,result,A1,A2,ff;
result:={};A1:=A;A2:={};F1:=F;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false"> while A1&lt;&gt;A2 do </Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">   A2:=A1;ff:={};</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">   for f in F1 do</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">     if  (f[2]=0 and                 `minus`(`minus`(f[3],A1),f[5])={}) or (f[2]=1 and nops(`minus`(f[3],A1))&lt;=f[4] ) then</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">        A1:=`union`(A1,f[3]);</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">        ff:=`union`(ff,{f});</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">     fi;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">   od;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">   F1:=`minus`(F1,ff);</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">od;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">RETURN(A1);</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">end:</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">
</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan[ApQuanhe]:=
proc(D::list,A::set)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">  local Anew, i, f;
Anew := A;
for i from 1 to nops(D) do
  f := D[i];
  if ((f[2]=1 and nops(`minus`(f[3],Anew))&lt;=f[4]) or
      (f[2]=0 and `minus`(`minus`(f[3],Anew),f[5])={}))
     and 0&lt;nops(`minus`(f[3],Anew)) then
    Anew := `union`(Anew,f[3]);
  fi;
od;
RETURN (Anew);
end:</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan[Solutionw]:=
proc(filename::string,A1::set,B1::set)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">  local F,f,Aold,sol_found,sol,A, i,j,D,D1;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">    F:=ReadObjectw(filename)[3];</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">    sol:=[];</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">    Aold:={};
    A:=A1;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">    if `minus`(B1,A1)={} then</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">      sol_found:=true;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">    else</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">      sol_found:=false;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">    fi;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">    while (sol_found=false and Aold&lt;&gt;A) do </Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">      Aold:=A;
      for i from 1 to nops(F) do
        f := F[i];
        if ((f[2]=1 and nops(`minus`(f[3],A))&lt;=f[4]) or
          (f[2]=0 and `minus`(`minus`(f[3],A),f[5])={}))
          and 0&lt;nops(`minus`(f[3],A)) then
          A := `union`(A,f[3]);
          sol:=[op(sol),f];
          # F:=`minus`(F,{f});
          break;
        fi;
      od; # for
      if `minus`(B1,A)={} then
        sol_found := true
      fi
    od; # while</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false"> if sol_found then
   # Loai bot cac quan he khong can thiet
   D := sol;
   for i from nops(sol) by -1 while i&gt;0 do
     f := sol[i];
     for j from nops(D) by -1 while j&gt;0 do
       if D[j]=f then
         D1 := [op(D[1..(j-1)]),op(D[(j+1)..nops(D)])];
       fi;
     od;
     if `minus`(B1,ApQuanhe(D1,A1))={} then
       D := D1;
     fi;
   od;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">   RETURN([true,D]);
 else
    RETURN([false,[]]);
 fi;</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false"> end:
</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan[OpSolutionw] :=
proc(filename::string,H::set,G::set)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">local 
   F::list, #danh sach quan he doc tu file
   Alist::list, #danhsach cac tap thuoc tinh o cac dinh
   Open::set, Close::set, found,
   node, # so thu tu cua dinh, so do ham g,
         # so thu tu cua quan he,so thu tu dinh truoc
   f, A, nodelist, k, sol,
   GetMin,Xuly_next;

GetMin := proc()
  local node, minnode;
  minnode := Open[1];
  for node in Open do
    if node[2] &lt; minnode[2] then
      minnode := node;
    fi;
  od;
  Open := `minus`(Open,{minnode});
  RETURN(minnode);
end: # GetMin

Xuly_next := proc(node,f)
  local node1, Aset, Bset,g, nAlist, i;
  nAlist := nops(Alist);
  Aset := Alist[node[1]];
  Bset := ApQuanhe([f],Aset);
  node1 := [op(node)];
  for i from 1 to nAlist do
    if Bset = Alist[i] then break;
    fi;
  od;
  if i &gt; nAlist then # dinh moi
    g := node[2]+f[7];
    Alist := [op(Alist),Bset];
    node1 := [nAlist+1,g,f[1],node[1]];
    Open := `union`(Open,{node1});
  else
    for node1 in Open do
      if node1[1]=i then
        if node[2]+f[7] &lt; node1[2] then
          Open := `minus`(Open,{node1});
          node1 := [i,node[2]+f[7],f[1],node[1]];
          Open := `union`(Open,{node1});
        fi;
        break;
      fi;
    od;    
  fi;
end: # Xuly_next

F := ReadObjectw(filename)[3];
Alist := [H];
# Buoc 1:
node := [1,0,-1,-1];
Open := {node};  Close := {};  found := false;
# Buoc 2:
while (Open &lt;&gt; {}) do
  node := GetMin(); # lay ra dinh nho nhat trong Open
  Close := `union`(Close,{node});
  if `minus`(G,Alist[node[1]]) = {} then # node is goal
    found := true;
    break;
  fi;
  for f in F do
    A := Alist[node[1]];
    if ApQuanhe([f],A) &lt;&gt; A then
      Xuly_next(node,f);
    fi;
  od; # for
od; # while
# Buoc 3: Ket luan
if found = true then
  nodelist := [node]; 
  while node[1] &lt;&gt; 1 do
    k:=node[4];
    for node in Close do
      if node[1] = k then
        nodelist := [node,op(nodelist)];
        break;
      fi;
    od; # for
  od; # while
  sol := [];
  for k from 2 to nops(nodelist) do
    node := nodelist[k];
    for f in F do
      if f[1]=node[3] then  sol := [op(sol),f];
      fi;
    od;
  od;
  RETURN([true,sol]);
else
  RETURN([false,[]]);
fi;
end: # OpSolutionw</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">
</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan[EvalSolw] :=
proc(F::list,H::set,G::set)
local Aold, Anew, setlist, f,
      result, i, bien, expr, rhs_expr;
Aold := H;  setlist := [Aold];
for f in F do
  Anew := ApQuanhe([f],Aold);
  setlist := [op(setlist),Anew];
  Aold := Anew;
od;
f:=F[nops(F)];  result := solve(parse(f[6]),G);
for i from nops(F)-1 by -1 while i&gt;0 do
  f := F[i]; bien:=`minus`(setlist[i+1],setlist[i]);
  for expr in result do
    result := `minus`(result,{expr});
    rhs_expr := subs(solve(parse(f[6]),bien),rhs(expr));
    expr := lhs(expr)=rhs_expr;
    result := `union`(result,{expr});
  od;
od;
RETURN(simplify(result));
end: # EvalSolw

</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan[Basew] := proc(F)
# Gia su cac quan he trong F co rank = 1
local A1, F1, S, f,f1,uf,vf, x,Atmp,
    After;
After := proc(vf::set) # xet tren (A1,F1)
  local f1,A,Aold;
  A := vf;  Aold := {};
  while A &lt;&gt; Aold do
    Aold := A;
    for f1 in F1 do  
      if `intersect`(`minus`(f1[3],f1[5]),A) &lt;&gt; {}
      then  A := `union`(A,f1[5]);
      fi;
    od;
  od; # while
  RETURN(A);
end: # After

# Buoc 1:
A1 := {};  F1 := {};  S := {};
# Buoc 2:
for f in F  do
  # Xu ly truong hop 1 cua f
  if `minus`(f[3],A1) = {} then
    if (f[2]=1 and `intersect`(f[3],S)&lt;&gt;{}) or
       (f[2]=0 and `minus`(f[5],S)={}) then
      if f[2]=1 then Atmp := `intersect`(f[3],S);
      else Atmp := f[5];
      fi;
      for x in Atmp do
        if `intersect`(`minus`(f[3],{x}),After({x}))={}
          then
          S:=`minus`(S,{x}); f[5]:={x}; f[2]:=0;
          F1:=`union`(F1,{f});
          break;
        fi
      od;
    fi;
  fi;
  # Xu ly truong hop 2 cua f
  if `minus`(f[3],A1) &lt;&gt; {} then
    if f[2]=1 or `minus`(f[5],A1)&lt;&gt;{} then
      vf := {`minus`(f[3],A1)[1]};  
      uf := `minus`(f[3],vf);
      S := `union`(S,`minus`(uf,A1));
      A1 := `union`(A1,f[3]);
      f[2]:=0; f[5]:=vf;
      F1 := `union`(F1,{f});
    else
      vf := f[5]; uf := `minus`(f[3],vf);
      # Loai quan he trong F1 suy ra vf
      for f1 in F1 do
        if f1[5] = vf then
          F1 := `minus`(F1,{f1}); break;
        fi;
      od;
      # Loai mot so quan he trong F1 de bao dam tinh phan
      # cap va cap nhat level cua cac phan tu
      Atmp := `minus`(uf,A1);
      for x in `intersect`(uf,A1,After(vf)) do
        for f1 in F1 do
          if f1[5]={x} then
            Atmp := `union`(Atmp,{x});
            F1 := `minus`(F1,{f1});
            break;
          fi;
        od;
      od; # for x
      S := `minus`(`union`(S,Atmp),vf);
      A1 := `union`(A1,f[3]);
      F1 := `union`(F1,{f});
    fi;
  fi;
od; # for f
RETURN([S,A1,F1]);
end: # Basew

</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan[Completionw] := proc(F,H::set,G::set)
local Aset, Fset, BaoH, G1, H1,
      f, ans, k;
  Fset := convert(F,set);
  Aset := {};
  for f in Fset do
    Aset := `union`(Aset,f[3]);
  od;
  Aset := `minus`(Aset,`union`(G,Baodongw(Fset,H)));
  ans := false;  k := 0;
  while (ans = false) and k &lt;= nops(Aset) do
    for H1 in combinat[choose](Aset,k) do
      BaoH := Baodongw(Fset,`union`(H,H1));
      if `minus`(G,BaoH) = {} then
        ans := true;
        break;
      fi;
    od;
    if ans &lt;&gt; true then  k := k+1;
    fi;
  od; # while
  RETURN([ans,H1]);
end: # Completionw

</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">MangTinhToan[Completionw1] := proc(F,H::set,G::set)
# Gia su cac quan he trong F co rank = 1
local A1, F1, S, f,f1,uf,vf, x,Atmp,Atmp1, G1,
    After;
After := proc(vf::set) # xet tren (A1,F1)
  local f1,A,Aold;
  A := vf;  Aold := {};
  while A &lt;&gt; Aold do
    Aold := A;
    for f1 in F1 do  
      if `intersect`(`minus`(f1[3],f1[5]),A) &lt;&gt; {}
      then  A := `union`(A,f1[5]);
      fi;
    od;
  od; # while
  RETURN(A);
end: # After


# Buoc 1:
G1 := `minus`(G,H);
A1 := H;  F1 := {};  S := H;
# Buoc 2:
for f in F  do
  # Xu ly truong hop 1 cua f
  if `minus`(f[3],A1) = {} then
    if (f[2]=1 and `intersect`(f[3],S)&lt;&gt;{}) or
       (f[2]=0 and `minus`(f[5],S)={}) then
      if f[2]=1 then Atmp := `intersect`(f[3],S);
      else Atmp := f[5];
      fi;
      Atmp1 := {};
      for x in Atmp do
        if `intersect`(`minus`(f[3],{x}),After({x}))={}
          then  Atmp1 := `union`(Atmp1,{x});
        fi
      od;
      if Atmp1 &lt;&gt; {} then
        if `intersect`(Atmp1,G) &lt;&gt; {} then
          vf := {`intersect`(Atmp1,G)[1]};
        elif `minus`(Atmp1,H) &lt;&gt; {} then
          vf := {`minus`(Atmp1,H)[1]};
        else vf := {};
        fi;
        if vf &lt;&gt; {} then 
          S:=`minus`(S,vf); f[5]:=vf; f[2]:=0;
          F1:=`union`(F1,{f});
        fi;
      fi;
    fi;
  fi; # end truong hop 1
  # Xu ly truong hop 2 cua f
  if `minus`(f[3],A1) &lt;&gt; {} then
    if f[2]=1 or `minus`(f[5],A1)&lt;&gt;{} then
      vf := {`minus`(f[3],A1)[1]};
      if `minus`(vf,H) &lt;&gt; {} then  
        uf := `minus`(f[3],vf);
        S := `union`(S,`minus`(uf,A1));
        A1 := `union`(A1,f[3]);
        f[2]:=0; f[5]:=vf;
        F1 := `union`(F1,{f});
      fi;
    elif `minus`(f[5],H)&lt;&gt;{} then
      vf := f[5]; uf := `minus`(f[3],vf);
      # Loai quan he trong F1 suy ra vf
      for f1 in F1 do
        if f1[5] = vf then
          F1 := `minus`(F1,{f1}); break;
        fi;
      od;
      # Loai mot so quan he trong F1 de bao dam tinh phan
      # cap va cap nhat level cua cac phan tu
      Atmp := `minus`(uf,A1);
      for x in `intersect`(uf,A1,After(vf)) do
        for f1 in F1 do
          if f1[5]={x} then
            Atmp := `union`(Atmp,{x});
            F1 := `minus`(F1,{f1});
            break;
          fi;
        od;
      od; # for x
      S := `minus`(`union`(S,Atmp),vf);
      A1 := `union`(A1,f[3]);
      F1 := `union`(F1,{f});
    fi;
  fi;
  # Cap nhat G1
  G1 := `minus`(G1,A1);
od; # for f

RETURN([S,A1,F1]);
end: # Completionw1

</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">save(MangTinhToan,"D:/TAM/MangTinhToan.m");</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">restart;</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">?record</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">?module</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Text-field/></Worksheet>